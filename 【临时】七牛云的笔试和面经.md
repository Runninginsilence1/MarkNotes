


# 笔试
## 18年卷1
**92^500 除以 11 的余数是：**
这个题目考的是数论中费马小定律： 如果一个数是指数，并且gcd什么 -> 求余数应该等于1。

**概率题**
这个没办法，我现在可没办法重新学习一次概率论了。
总之思路好理解，不是很难：

**计网：在TCP连接中，主动断开的一方发出了FIN包之后，socket处于什么状态？**
三次挥手和四次挥手的过程，这个看有没有必要重新回顾一下这个过程。
Fin包的话对面是CLOSE_WAIT的状态。

**C语言（应该说是操作系统方面的知识），fork函数的作用**
fork类似于github里面的那个fork的含义，类似于clone，但是可以根据参数发生完全不同的状态。

但是这个的答案我不知道。

**nginx作为代理服务器的知识：**
400 - Bad Request，请求无效，说明请求没有提交到后台服务中；
404 - Not Found，无法找到服务器；
500 - Not Implemented，服务器不支持当前请求所需要的某个功能；
502 - Bad Gateway，作为网关或者***工作的服务器尝试执行请求时，从上游服务器接收到无效的响应网关错误。是由于对用户访问请求的响应超时造成的

**数据结构大根堆和小根堆**
利用有效的时间快速查找资料和得到的结论：
堆是一种完全二叉树
堆是为了查找最值维护的结构
根据最大值和最小值的区别分为大根堆和小根堆；
crud的时候会维护这个数据结构；

**排序算法**
给一个具体的排序算法，你要怎么判断哪种算法最优？
这个主要是两种：
1. 不管具体的数组，主流排序中时间复杂度基本都是O(logN)
2. 一个接近有序的数组，直接使用冒泡或者插入的速度最快


**5个进程共享同一程序段，而且每次最多允许3个进程进入该程序段，则信号量的变化范围是**
这个是操作系统进程相关的知识：
互斥量mutex的知识（共享内存）

**程序段最多允许三个进程进入**，-> 为3，因此，信号量初值为3，**每进入一个进程，信号量的值减1**，当信号量的值减为0时，表示三个进程均进入程序段，此时若再有一个进程请求进入执行P操作，则信号量的值减为-1，进程阻塞。一共有五个进程，所以信号量的值最小为-2。因此信号量的值取值范围为3，2，1，0，-1，-2。因此应该选D。

**三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？**
这种要画图。 我以前学习os的时候也是画过的。 虽然分数不高。
如果下面的评论还在纠结哪个是正确答案的话，那就暂时不要花时间去搞正确答案。


**二叉树的相关知识**
深度的那个我自己推断出来了。 主要就是一个要知道概念；然后算法相关的题目也考得非常的多

**大小端**
知道有这么回事。
如果其他卷子也考的话那就有必要看看了。。。

## 18年卷2
**找数字规律**
这种一般不会太难。有点耐心即可。

**在局域网上执行 ping www.qiniu.com 没有涉及到的网络协议是？**
计网。
dns肯定有：域名解析服务，实现好记的网址与ip地址之间的转换；
tcp肯定有：在传输层，是可靠连接的基石；
arp用于将ip地址转换为物理的mac地址，在局域网中；应该也是有的；
ICMP是网络层协议，用于在主机和路由器之间传递控制信息。

**有三个节点，可以构成多少种二叉树**
感觉侑多种思路...不在这个上面浪费时间

**数据库相关**
下列对于数据库索引的说法一定是错误的？

这个在牛客的解析那里有一个评论非常的详细。 可以去看看；

**fork**
又考到fork了；
主要还是这个玩意的作用以及对流程严谨度的考验；

**Linux 下两个进程同时打开同一个文件，这时以下描述正确的是**
Linux操作系统的相关知识：
fd就是文件的句柄，相当于编程语言里面的标识符（变量名）
每一个进程维护一个独立的标识符表，但是同一个标识符也可以被不同的进程给引用；

os在两个进程同时操作同一个文件时，不保证原子性。

os有对文件加锁的功能；

**如果一个数组（长度超过10万）仅由0-10的整数组成，以下哪种排序算法对该数组排序效率最高**
知识点：
如果元素在一个小范围内，那么使用技术排序的话可以控制复杂度到O(N)

它是一个不需要比较的，类似于桶排序的线性时间排序算法。该算法是对已知数量范围的数组进行排序。其时间复杂度为O(n)，适用于小范围集合的排序。

**Linux的基础知识**
关于Linux的文件系统：
inode是一串“类似于”id的号码，文件名与inode一般情况下是一一对应的；
但是 前者与后者的关系也可以是多对一；

这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。

inode相当于一个meta data;

**又是数学题**
又是一个概率论的题型。 
研究起来不知道又要多少时间。

**概率论**
5 个骰子，六个面分别标有1-6，现在将五个同时随机投掷，五个点数之和概率最大的点数是：

重温了数学期望的概念：就是概率相加

**Linux基础命令**
验证远端服务器（IP：180.97.72.166）的 1935 端口是否开启的命令是
telnet 180.97.72.166 1935

**Linux进程通信的方式**
这个记住就行：
管道 或 消息队列 或 信号量 或 共享内存 或 套接字

**当线上出现问题的时候**
定位问题进程->定位问题线程->查看问题线程堆栈->内存问题定位->定位问题代码

因为本质上还是数据嘛。


## 18年卷3
**统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？**
又是数学题。
十字交叉法： x + y = 1; ax + by = c => x/y = (c - b)/(a - c)

怎么考这种几把题目啊，真几把蚌埠住了

**C语言关于数据类型的一个细节**
看这个是不是false可以直接被int接受，值是0

**以下数据结构的说法，错误的是**
这个考察一些高级的数据结构的特点：
红黑树：
Bplus树
哈希表
链表

**在64位操作系统上，如下数据结构占用的存储空间大小为多少字节**
编译器的细节；操作系统；内存对齐（内存对齐我当初也看了不少的时间。。。）；
这个比较底层了，暂时先放在这里

# 面试
## 我的简历中可以挖的点
1. Go语言的面试题
2. Gin框架的一部分东西
3. MySQL和innodb
4. 计网
5. git
6. 项目
   1. 一个经典的前后端分离；主要还是深挖框架
   2. BT下载器：你对Bencode协议的了解，以及怎么实现这个程序的；
   3. Android相关的东西，但是我觉得应该不算重点...

## 计网相关

## 排序相关
重要的就是四个排序：快排、递归排序、冒泡排序、希尔排序。
**冒泡**简单： 核心思想就是：n个元素的数组排n-1趟，每次一定可以确认一个元素的位置； 如果真的考到的话一般会让你手撕； 冒泡排序稳定。 **稳定就是指：相同权重的元素，在排序的前后，他们的相对位置是不会发生变化的。**
并且冒泡排序可以优化： 如果发现集合已经有序了，那就不需要继续下面的趟数了。 可以在每一趟冒泡之前**加上一个标志位判断这一趟下来是否发生了排序。**


**快速排序**
本质上也是归并排序：我个人的理解是：归并是先解决子问题，然后再回来排序； 快排是先确定整个大数组中某一个元素的位置，然后去递归的解决左右两边的子问题；
**快排最重要的特点是**快速排序的**平均时间复杂度**也是O(nlogn)，不过他不需要像归并排序那样，还**需要一个临时的数组来辅助排序**，这可以节省掉一些空间的消耗，而且他不像归并排序那样，把**两部分有序子数组汇总到临时数组之后，还得在复制回源数组，这也可以节省掉很多时间**。

在对目标值之外的元素进行移动的时候，可以采用**双向移动**的原理：
也就是left和right是不包含target的元素；然后i和j各自从边界开始移动：i大于target，则停止；然后j开始：j小于target，则停止；此时两个都停止的时候，  交换i和j的值，然后两个都对应移动一格；

这个就是快排的核心思路；

```java
方法二：双向扫描
int partition2( int[] arr, int left, int right)
{
 int pivot = arr[left];
 int i = left + 1;
 int j = right;
 while(true)
 {  
   //向右遍历扫描
   while(i <= j && arr[i] <= pivot) i++;
   //向左遍历扫描
   while(i <= j && arr[j] => pivot) j--;
   if(i >= j)
     break;
   //交换
   int temp = arr[i];
   arr[i] = arr[j];
   arr[j] = temp;
 }
 //把arr[j]和主元交换
 arr[left] = arr[j];
 arr[j] = povit;
 return j;
}
```

**归并排序**
它一下就在快速排序里面过了；
归并就是需要子数组有序，那么就可以用一个递归使得所有的子数组有序，然后在子数组合并的时候使得他们有序即可；

**希尔排序**
它是插入排序的改良版； 它的时间复杂度的证明极其复杂...
**插入排序**的核心思想就是**在一个已经有序的数组里面，把一个新元素插入的过程。** 在数组一定规模有序和数据量少的时候效率很高。

而希尔排序可以使得数据规模增大的原因是： 通过设置间隔（这个被叫做“增量”），使得一个数组产生逻辑上的分组：这就满足了插入排序高效的第一个情况数据量少；
然后通过插入排序就可以使得这一组数组变得有序； 此时整个数组处于**部分有序**的状态。
然后缩小增量，这样每组里面的元素会增多；但是此时组内也已经处于部分有序状态，这就满足了插入排序高效的第二个情况数组处于部分有序的状态

它大概是什么东西我倒是看懂了，但是代码的话...以及核心的原理我也还是没有弄清楚；

## 后端实习一面，但是作者寄了...
1. MySQL时的，B和B+树；然后是红黑树avl以及bst。 还会问bst以及avl的区别；
2. 哈希表：主要是为什么可以O(1)复杂度、哈希碰撞、语言的内部实现之类的；
3. 第三是问项目里面的内容： 我这里可能主要就是gin和mysql了。


## 七牛云后端开发实习面经（这个oc了）



# 如果确实有面试那么，自我介绍也是很重要的
可以学习一下牛客上自我介绍，肯定是要在软件方面有作用的。

# MySQL相关的
首先看了技术蛋老师的视频重新回顾了一遍，讲的既生动又透彻。

## 数据库结构的一些名词
数据库系统里面，每个数据库都被成为**scheme**，英文就是架构、方案的意思；
用excel作类比的话，MySQL软件就相当于excel这个软件，而里面的每个excel文件就是不同的数据库。 而数据库里面的表格就是不同的标签，因为excel里面不同的表格就相当于不同的标签；

## Default这个关键字
用于设置列的默认值（如果有默认约束或者主键设置的是auto_increment的话）

## ALTER关键字修改表格的结构
```sql
ALTER TABLE 数据库名.表格名
ADD 列名 数据类型 默认条件
```

## 使用LIKE进行模糊匹配的时候
`%`有点类似命令行中使用的通配符;
`_`有点类似正则里面的`.`这个字符；

## JOIN 连接
ON进行连接的定位
INNER JOIN就是取的交集；

而UNION拼接合并结果集，并且默认去重，加上ALL关键字则不进行去重；

# Gin动态路由
实现原理底层就是前缀树；用斜杠分开的请求路径中，可以通过前缀树来匹配对应的handler

# Gin中间件
个人感觉在业务需求中的作用，和aop的非常像：就是解耦合，拆逻辑；可拓展；
例子：比如我可以为每个用户的请求加上**鉴权的中间件**，这样就把这个逻辑给抽离出来了。

日志中间件：
```go
func Logger() frame.HandlerFunc {
  return func(c *frame.Context) {
    // Start timer
    t := time.Now()
    // Process request
    c.Next()
    // Calculate resolution time
    log.Printf("[%d] %s in %v", c.StatusCode, c.Req.RequestURI, time.Since(t))
  }
}
func main() {
  app := frame.New()
  group_1 := app.Group("/group_1")
  group_1.Use(Logger())
  group_1.GET("/name", func(c *frame.Context) {
    c.String(http.StatusOK, "访问成功")
  })
  app.Run(":8080")
}
```
我的理解：
`/login/username`比如这个，它转换成对应的代码就是：
```go
r := gin.New()
// 添加一个组：
group_1 := r.Group("/login")
// Use方法加载中间件函数
group_1.Use(mid func(c *gin.Context))
// 然后就是静态路由
// ...
```

gin的一个核心应该就是这个gin.Context，用于保存各种上下文信息。
context这玩意就是一个**状态的大杂烩**，
比如中间件的执行顺序的判定，就是如下注释解释的实现方法一样：
```go
type Context struct {
  // origin objects
  Writer http.ResponseWriter
  Req    *http.Request
  // request info
  Path   string
  Method string
  Params map[string]string
  // response info
  StatusCode int
  // middleware：
  // 这个上下文包含的中间件函数
  handlers []HandlerFunc
  // 表示执行到第几个函数了
  index    int
}
```

通过Next()方法来调用这些中间件；

算了这里不深入研究了。

# Go Tag的机制
就是struct每个字段的额外的信息；通过运行时的反射来获取。
tag会保存到这个结构体的元数据（也是一个struct）中，然后在运行时通过反射获取到这个结构体，然后遍历并获取到执行的信息。


chatgpt的回答：
Go语言的tag机制是通过反射实现的。每个结构体字段都可以使用tag来标识其属性，例如json、xml、bson等。在编译时，编译器会将tag信息保存在结构体的元信息中，这些元信息可以在运行时通过反射获取。

当我们在代码中使用反射获取某个结构体字段的tag时，Go语言会在运行时通过遍历结构体类型的元信息来获取tag信息。具体来说，Go语言会将结构体类型的元信息保存在一个结构体类型的对象中，该对象包含了结构体的所有字段信息，以及每个字段的tag信息。在运行时，我们可以使用反射获取这个结构体对象，并通过这个对象来获取每个字段的tag信息。

总的来说，Go语言的tag机制是通过反射实现的，它可以让我们在编译时给结构体字段打上标签，然后在运行时通过反射获取这些标签信息。这种机制为我们提供了一种方便的方式来处理结构体的元数据，使得我们可以更加灵活地处理结构体数据。
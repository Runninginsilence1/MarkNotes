# 计网重要的面试题
# 五层协议
## 物理层
在物理阶段, 现实意义的连接两台机器. 比如电缆线或者什么的, 传输物理意义上的信号.

## 数据链路层
如果只有物理层那肯定是什么也做不好的. 好比什么都不给让你写一篇英语作文. 因此我们需要制定一些规则, 来使得这些**信息的组织变得有规律**. 
这个规律, 就是现在的**以太网协议**

> 以太网协议: 以太网协议规定，一组电信号构成一个数据包，我们把这个数据包称之为帧。每一个桢由标头(Head)和数据(Data)两部分组成。
> Head 里面存储数据的说明信息, Data里面自然就是对应的数据了. 区分头和data的方式是**固定头的大小, 固定为18个字节.**

并且, 不同的网络设备之间**需要一个可以用来区分彼此身份的地址(Addr)**, 这个地址就是 MAC地址.

> 连入网络的每一个计算机都会有**网卡接口**，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。
MAC地址 由 48 个二进制位所构成，在网卡生产时就被唯一标识了. (不过肯定是可以修改的, 在数据的层面.)

## 网络层
**广播和ARP地址**
光是知道地址也无法直接传送信息, 比如我告诉你我住在英国伦敦的贝克街213号. 然后你就准备给我送快递了吗? 肯定不行. 
计算机同理. 计算机 A 不仅连着计算机 B，而且计算机 A 也还连着其他的计算机。 虽然计算机 A 知道计算机 B 的 MAC 地址，可是计算机 A 却**不知道计算机 B 是分布在哪边路线上**，为了解决这个问题，于是，有了广播的出现。

不过广播这个词语本身并不是这个意思. 所以联想一下, 这个词语可以意味着广播实际上是一个**解决方案**: 向线路里面的设备发送包含指定 MAC地址的数据报. 这个过程就像是:

> 这种发送方式我们称之为广播,就像我们平时在广场上通过广播的形式呼叫某个人一样，如果这个名字是你，你就理会一下，如果不是你，你就当作听不见。

那ARP协议又是什么呢? 只讨论它的存在意义的话, 很简单啊! 计算机 A 是如何知道计算机 B 的 MAC 地址的呢？ 就是通过这个 ARP 协议. 
+ [x] ~~2022-08-14 12:18~~ ARP协议原理
ARP协议的运作依赖 IP地址. 
> ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。这样，计算机A就能知道计算机B的MAC地址了。

我的理解是, 这个arp协议**只有在不知道对应机器的 MAC地址 的时候**用上面这种方式获得 设备的 MAC地址. 
不过这样一来, 我的疑问就来了, 传输数据用的是广播, 然后比对 IP地址. ARP协议获取 IP地址也是用这种方式, 那么 **mac地址本身好像从来没有用到过似的**...

> 可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。

**DNS**
DNS的概念因为做过 Linux的考试, 所以这个东西本身是干什么的我很清楚. 具体原理的话这里也没解释, 所有就写成这个程度.


刚刚上面里面提到了广播, 那么就不得不提到子网了. 
还是用广播做联想, 在学校里面播放的广播, 你在家里面的妈妈可以听到吗? 理论上播放广播的人是只想让你听到的对吧. 
那么在计算机网络里面, 我们保证, 发送数据的时候, 只在一个子网里面广播, 如果需要传输到子网外面, 那么就需要网关. 比如你麻麻如果要听到学校广播, 她可以用一台收音机.

由这个地方引出 IP地址.


**IP地址**
暂时只讨论 IPv4.
这个 IP 地址由 32 位的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255。

每一个联网的机器都会有 IP地址, 分为网络地址 和 主机的地址, 前者就是子网的地址, 后面就是网络的地址. 通过**子网掩码** 可以知道 IP地址的网络地址和主机地址对应都是多少位.

**因此，网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。**

## 传输层
**传输层是计网的重点.** 众所周知的 TCP, UDP 协议都在这一层.
前三层, 帮助我们实现信息跨计算机的传输了. 传输层就是计算机内部层面的网络协议了. 

只说大概, 也很简单, 使用 端口(Port). 端口好比设备内部的 IP地址.

这个总结的很好: 
**也就是说，传输层的功能就是建立端口到端口的通信。相比网络层的功能是建立主机到主机的通信。**

## 应用层
最接近用户的一层, 这里基本已经是交给程序处理的部分了. 这里的就是 HTTP 协议什么的.


# 通信双方保证信息不丢失
由**数据链路层**的结论可知, 数据的传输是分成一个个小的分组传送的.
导致数据不正确的可能有两个原因: 

1. 这个分组在传输的过程中，由于在信道传输过程中，受到干扰，导致这个分组到达目的地之后**出现了差错**，例如分组里面的二进制位1变成了0，0变成了1。
2. 分组还没传输到目的地，就丢失了，我们也把这种情况称之为丢包。

> 第一个的话好像是有一个校验的机制, 然后解决的方式也简单粗暴, 发送方直接重传. 

> 第二个也是重新传送, 不过这次又引出了一个效率的问题, 使用**流水线解决**

确保这个流水线正常运作的就是所谓的 **滑动窗口协议**.

## 回退N步协议(GBN) 滑动窗口协议
在回退N步法中允许发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。如下图，我们将基序号定义为最早的未确认分组的序号，将下一个序号(nextseqnum)定义为最小的未使用序号(即下一个待发送分组)。

我说说我自己的理解.
![Img](./res/drawable/滑动窗口协议.png)

绿色, 已经被双方认可都发送成功的数据. 
橙色, A觉得我发了, 但是 B还没有回复我到底有没有发送成功. 
黄色, A在橙色变成绿色之后, 就准备开始发送的内容. 
蓝色, A觉得还没轮到你们. 

发送方(下文用A表示) 在这个协议里面需要处理两个事件: 
1. A 收到的 ACK代表序号n 以及n前面的内容已经成功交付. 
1. 如果超时(没有接收到B发来的 ACK信号), A会重新发送橙色的内容.

接收方(下文用B表示) 在这个协议里面需要处理一个事件: 
如果一个序号为n的分组被正确收到，并且按序(所谓按序就是指n-1的分组也已经收到了)，则B为分组n发送一个ACK，否则，丢弃该分组，并且为最近按序接收的分组重新发送ACK。
接收方的这种处理方式，意味着如果n被正确交付，则意味着比n小的所有分组也被正确交付了。

这种方式有一个显而易见的缺点, 就是他的效率并没有提高多少, 和前面的重新发送是差不多的.
> 回退N步协议的缺点也是很明显的，单个分组的差错能够引起GBN重传大量的分组，而且许多分组根本就没有必要重传。例如我们发送的序号为0-100，万一序号为1的分组出现了某些差错，这会导致1-100的分组会被重传，想想这是多么恐怖的事情啊。

是的这句话的意思很简单, 如果因为这一个导致100个要重新弄, 这也太蠢了, 明显有可以优化的空间. 


**选择重传**

我片面的理解: 知道滑动窗口里面对应的数据全部都变成绿色了再考虑移动窗口的事情.

窗口的大小 N 由**拥塞控制** 决定.

# 简述 集线器、交换机与路由器有什么区别？
先说说最简单的连接吧. 
每个电脑都一个网线口, 可以连接网线. 这就是之前说到的直接的物理连接.

可是, 如果数量一个, 口子却只有一个, 那么这种方式就不行. 于是就使用一个中介, 他有多个网线口, 可以负责连接各个设备.
这个东西就是 **集线器**. 他在物理层.

不过机器一多, 就有精准发送信息的需求了. 

那么根据地址负责**精准传输**的设备就是**交换机**. 他在数据链路层.

那么如果人越来越多, 以致于一些没有网线的人也想来加入连接了, 彼此之间的信息交流都不一样, 那这是怎么办呢?

那这个措施就是统一语言: 比如统一成英语. 

> 那如何实现呢？小伙伴们规定，不同的村子间先在各自的操作系统上加上一套相同的协议。不同村落通信时，信息经协议加工成统一形式，再经由一个特殊的设备传送出去。这个设备就叫做路由器。路由器通过IP地址寻址，我们说它工作在计算机的网络层。

路由器就是做这个工作的, 他实现跨区域互联, 位置在分层的**网络层**.

总结: **交换机适合局域网内互联，路由器实现全网段互联。**

# 【番外篇】Sakura FRP 介绍的内网穿透的知识
整篇我都看完了, 没有太过于难以理解的知识: 
Sakara FRP 提供 公网ip
电脑A和电脑B的连接大概是这样一个过程: 
A电脑 地址:端口 ←→ FRP提供隧道: 代理地址:端口 ←→ B电脑 地址:端口
# 什么是 TCP 拥塞控制？
> 大家可能都听说过拥塞控制和流量控制，想必也有一些人可能还分不清拥塞控制和流量控制，进而把他们当作一回事。拥塞控制和流量控制虽然采取的动作很相似，但拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。

也就是说，拥塞控制和流量控制是**针对完全不同的问题而采取的措施**.

## 拥塞控制有什么作用
一般来说，两台主机在传输数据包的时候，如果发送方迟迟没有收到接收方反馈的 ACK，那么发送方就会认为它发送的数据包**丢失了**，进而会重新传输这个丢失的数据包。

然而事情情况是, 是因为**本来路就堵**. 

以送快递做例子, A 给B寄了一个东西, 要求B收到之后发一个回复消息给A. 但是因为堵车, 这个东西B一直没有收到, 那么A**错误的以为东西已经丢了, 而实际上东西还在路上**, 导致路变得**更加拥挤.**

这种情况毫无疑问需要避免. 引入拥塞控制:

妈的这个东西让我想起来我学的计网了, 这个部分我是有印象的.

那么, 请允许我用自己的语言来组织.

## 拥塞控制流程

ssthresh: 阈值
所以最终的策略是：前期指数增长，到达阈值之后，就以一个一个线性的速度来增长。

最终肯定会出现超时事件，总不可能无限增长吧。当出现超时事件时，我们就认为此时网络出现了拥塞了，不能再继续增长了。我们就把这个时候的N的值称之为瓶颈值吧，用MAX 这个变量代替.

新的 ssthresh = MAX / 2

不过, 前面也说了, 导致A迟迟没有收到 ACK 确认信号的原因不只因为网络, 别忘了一开始提到的**数据报本身可能已经丢失或者损坏**.

需要一种机制来帮助**判断到底是哪一种情况**.

机制: 冗余 ACK

> 如果某个数据报N丢失, B会连续重传 ACK(N - 1), 如果此时定时器没有超时, 并且A收到了三个以上的 ACK, 那个就可以判断 数据报N已经丢失或者损坏, 这个时候A就不必等待N设置的计时器到期了，而是快速重传N。并且把ssthresh设置为MAX的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。

所以总结一下重要的: 
- 如果判断是网络拥堵, 那么滑动窗口的大小设置为1
- 若是丢失, 不是拥堵, 那么就把滑动窗口的大小设置为阈值 ssthresh, 提高效率. 并且拥有这种机制的 TCP 协议称作: TCP Reno

还有另外一种TCP版本，无论是收到三个相同的ACK还是发生超时事件，都把拥塞窗口的大小设为1，从最初状态开始，这种版本的TCP我们称之为TCP Tahoe。

# 什么是 TCP 流量控制
原理和拥塞控制其实差不多, 只不过解决的问题不同. 

## 需要进行流量控制的原因
因为双方的速率可能不对等. 那么此时相对双方而言**等效的速率就会是速度慢的那一边**. 对于快的那一边来说, 这就会**浪费大量的资源**. 所以你需要**维持双方速率的动态平衡**.

## 实现
接收方每次收到数据包，可以在发送确定报文(ACK)的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把**缓存区的剩余大小**称之为接收窗口大小，用变量 win 来表示接收窗口的大小。

不过这个可以存储 接受窗口的信息的报文是**有可能丢失**的, 此时双方可能就可能进入"死锁".

类似的, 可以使用"定时器策略": 

> 当接收方的 win的大小为0, 发送方停止发送的时候, 接收方可以考虑**设置定时器**以及**发送试探信号**.

## 一些注意事项
> 这里说明下，由于TCP/IP支持全双工传输，因此通信的双方都拥有**两个滑动窗口**，一个用于接受数据，称之为接收窗口；一个用于发送数据，称之为拥塞窗口(即发送窗口)。指出接受窗口大小的通知我们称之为窗口通告。

说人话就是双方都可以是发送者和接受者, 所以两边两个窗口都有.

> 现在的滑动窗口的大小是根据算法动态调整的.

滑动窗口的大小要适中, **太小浪费连接资源**, 太大则**没有必要并且浪费内存**.

# TCP三次握手(最频繁的面试题)
## 三次握手的过程: 
1. 第一次握手：客户端给服务器发送一个 SYN 报文。

2. 第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。

3. 第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。

4. 服务器收到 ACK 报文之后，三次握手建立完成。

我记得hsp将Java的网络的部分的时候也是说了这个的.

> 拨号的人: 你听到了吗?
> 收听的人: 我听到了, 你收到信就发个消息过来.
> 拨号的人: 好, 那我就开始发消息了.
> 拨号的人开始说话.

## 为什么要进行三次握手(通俗的版本)
三次握手的过程中确认的信息: 两端的发送用out表示, 接受用in表示, 最终情况是需要**双端的 in和out都正常**才能开始发送.
第一次握手: 服务器得出结论: 客户端的 out正常, 服务器的in正常;
第二次握手: 客户端得出结论: 服务器的 out正常, 客户端的in正常; 并且有这个消息可以得出第一次服务器握手时候的结论, 此时客户端已经可以确认双端都正常;
第三次握手: 服务器得出结论: 客户端的in正常, 服务器的out正常;

这个时候双方**都可以确认彼此之间可以正常发送消息了**, 所以开始发送消息.

## 加分描述(背这个)
需要记几个 专有的名词:
刚开始**客户端处于 closed 的状态，服务端处于 listen 状态**。
1. 第一次握手：客户端给服务端**发一个 SYN 报文**，并指明客户端的**初始化序列号** SN(c)。此时客户端**处于 SYN_Send 状态**。
    1. 第一次握手做三件事: 发送报文; 告知初始化的序列号SN(c); 进入 SYN_Send状态, 我理解的是**待发送**状态.;
1. 第二次握手, 服务器也会初始化自己的序列号ISN(s), (信息在SYN里面), 并且为了反馈**已经收到了来自客户端的信息**, ACK(Acknowledge)的值会设置为 客户端的 SYN的值加一. 此时服务器处于 SYN_REVD 的状态。
    1. 第二次握手: 服务器也初始化自己的序列 SYN, 并且设置 ACK 就是 客户端 SYN+1, 进入**待接收** 的状态。
1. 第三次握手: 也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
1. 最后就是服务器收到了, 双方建立连接. 

## 其他作用以及一些注意的点
- 确认双方的接受能力、发送能力是否正常。
- 指定自己的初始化序列号，为后面的可靠传送做准备。

ISN(Initial Sequence Number)不是固定的, 双方用这个数据告知对方接收数据的时候, 如何按序列号组装数据. 

如果ISN是固定的，**攻击者很容易猜出后续的确认号**，因此 ISN 是**动态生成**的。


**报文头部携带的数据的信息**

TCP首部占**32位字节**，其中有序列号seq，确认号ack以及标志位SYN，ACK，FIN等。
当标志位ACK = 1时，确认号ack的值才有效。
三次握手标志位与序列号、确认号的变化是：
SYN = 1, seq = ISN(c)
SYN = 1, ACK = 1, seq = ISN(s), ack = ISN(c) + 1
ACK = 1, seq = ISN(c) + 1, ack = ISN(s) + 1

# TCP的四次挥手
这个四次挥手就是**通信的双方结束连接的时候需要的步骤.**
首先因为有了之前三次握手的原因, 你**可能以为**TCP关闭连接的时候也是类似的三次. 其实不是的. 我用我自己的语言来解释一遍: 
TCP 是双边通信: 意味着连接建立后 双方都既可以是发送者和接受者. 不过**建立连接的时候**, 只要由一边发起请求就可以了. 

但是! 断开连接的时候, 由于双方**都有发送和接收**的功能, 所以需要关闭双方的发送和接收的功能. 这个**需要四次握手**的过程完成. 

## 过程
刚开始双方都处于 establised(意思是已建立连接) 状态，假如是客户端先发起关闭请求，则：
1. 第一次挥手: 客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 我个人的理解是, C 向 S发送信号, 我要停止发送了;
1. 第二次挥手: 服务端收到 FIN 之后，会发送 ACK(确认) 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明**已经收到客户端的报文**了，此时服务端处于 CLOSE_WAIT状态。 我个人的理解是: S收到了C的信息, 并且表示自己知道你要关了, 发送这个回复信息.
1. 第三次挥手: (此时C的发送已经停止, S的接受功能已经停止) 服务器也想关闭连接, 那么他就要**重复类似第一次挥手**时候的过程: 发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态;
1. 第四次挥手: 客户端接收到报文, 也发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时**客户端处于 TIME_WAIT 状态**(这个又叫做**延迟关闭**)。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态, 这是为了**防止出现服务器没有接收到自己的 ACK报文而自己提前关闭导致服务器阻塞的情况**. 
1. 最后, 服务器接收到了来自客户端的请求, 此时服务器关闭自己的连接, 处于 closed的状态.

重点就是为什么第四次挥手的时候需要设置一个延迟关闭的问题: 
> 就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

状态的含义: 
> LISTEN – 侦听来自远方TCP端口的连接请求；
  SYN-SENT -在发送连接请求后等待匹配的连接请求；
  SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认； 
  ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 
  FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 
  FIN-WAIT-2 – 从远程TCP等待连接中断请求； 
  CLOSE-WAIT – 等待从本地用户发来的连接中断请求； 
  CLOSING -等待远程TCP对连接中断的确认； 
  LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认； 
  TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 
  CLOSED – 没有任何连接状态；


# HTTP
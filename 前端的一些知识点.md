
# 常看常新

## 通过 axios向后端发送 post请求

示例代码
```js
export const getApiList = (data) => {
  return service({
    url: '/api/getApiList',
    method: 'post',
    data
  })
}
```

这里再补充一个get的：

```js
export const getApiList = (data) => {
  return service({
    url: `/api/getApiList?id=${data}`,
    method: 'get',
  })
}
```


【知识点】 vue3中自定义事件

Vue3的事件没有冒泡的机制，一个组件里面的时间，只能由它自己或者它的直接父组件监听到。 
**vue3官方推荐**的是使用 外部的事件总线库（例如emit，并且在公司的前端也有使用到这个库）或者使用全局状态管理（例如pinia）


【知识点】css animation

先用 `@keyframe` 制作动画
然后在css选择器中指定

示例代码： 实现一个div元素渐变的出现：
```css
.plugin-list {  
  .plugin-item {  
    opacity: 0;  
    width: 80vw;  
    height: 10vh;  
    background-color: yellow;  
    margin-top: 10vh;  
  
    animation: fadeIn 0.5s ease-in-out forwards;  
  }  
}  
  
  
@keyframes fadeIn {  
  from {  
    opacity: 0;  
    /* 起始透明度 */    transform: translateY(10px);  
  }  
  
  to {  
    opacity: 1;  
    /* 最终透明度 */    transform: translateY(0);  
  }  
}
```

【取证平板】接口请求失败的对话框，出现错误的时候就用这个方式来进行处理

```vue
<template>
<el-dialog
      v-model="failedDialogVisible"
      title="错误"
      width="80%"
      :show-close="false"
  >
    <span>无法连接到后台服务器</span>
    <template #footer>
      <span class="dialog-footer">
<!--        <el-button @click="cancelFetching">回到主页</el-button>-->
        <el-button type="primary" @click="clickRetry">
          重试
        </el-button>
        <el-button type="info" @click="failedDialogVisible = false;">
          取消
        </el-button>
      </span>
    </template>
  </el-dialog>
</template>


<script setup>
const clickRetry = () => {
  // 重试把对话框关掉，然后重试 loadData的方法
}


</script>
```


【知识点】在vue3中封装一个websocket


初始化一个websocket就是调用init方法。
init中包含设置生命周期的回调。
一个ws只有在触发onopen之后才能使用send来发送信息；

要处理服务端的数据包，只能在message生命周期里面才能处理回调信息。生命周期最好都处理一下，不然就容易出现我周五遇到的错误。

```ts
import { mitts } from "./tool";

/*
 * @Author: lzx
 * @Date: 2022-05-25 15:42:37
 * @LastEditors: lzx
 * @LastEditTime: 2022-08-18 15:01:38
 * @Description: Fuck Bug
 * @FilePath: \talk_pc\src\utils\socket.ts
 */
let socketUrl: any = ""; // socket地址
let websocket: any = null; // websocket 实例
let heartTime: any = null; // 心跳定时器实例
let socketHeart: number = 0; // 心跳次数
let HeartTimeOut: number = 3000; // 心跳超时时间
let socketError: number = 0; // 错误次数

// 初始化socket
const initWebSocket = (url: any) => {
  socketUrl = url;
    // 初始化 websocket
  websocket = new WebSocket(url);
  websocketonopen();
  websocketonmessage();
  sendSocketHeart()
};

// socket 连接成功
const websocketonopen = () => {
    websocket.onopen = function (e: any) {
        console.log("连接 websocket 成功", e);
        resetHeart();
    };
};

// socket 连接失败
const websocketonerror = () => {
    websocket.onerror = function (e: any) {
        console.log("连接 websocket 失败", e);
    };
};

// socket 断开链接
const websocketclose = () => {
    websocket.onclose = function (e: any) {
        console.log("断开连接", e);
    };
};

// socket 接收数据
const websocketonmessage = () => {
  websocket.onmessage = function (e: any) {
    let msg = JSON.parse(e.data);
    if (msg.type === 'heartbeat') {
      resetHeart()
      console.log("心跳");
    }
    // console.log("收到socket消息", JSON.parse(e.data));
    test(msg) // 测试数据
  };
};

// socket 发送数据
const sendMsg = (data: any) => {
    websocket.send(data);
};

// socket 错误
const websocketError = () => {
    websocket.onerror = function (e: any) {
        console.log("socket 错误", e);
    };
};



// socket 重置心跳
const resetHeart = () => {
    socketHeart = 0;
    socketError = 0;
    clearInterval(heartTime);
    sendSocketHeart();
};

// socket心跳发送
const sendSocketHeart = () => {
    heartTime = setInterval(() => {
    // 大概是： 重置心跳后，客户端发送两次心跳之后，就只接受服务端的信息了。
        if (socketHeart <= 2) {
            console.log("心跳发送：", socketHeart);
            websocket.send(
              JSON.stringify({
                content: "",
                requestId: "aa9872be-d5b9-478e-aba4-50527cd3ef32",
                type: "heartbeat"
              })
            );
            socketHeart = socketHeart + 1;
        } else {
            reconnect()
        }
    }, HeartTimeOut);
};

// socket重连 zzk: 根据 socketError的次数来判断是否进行重连；
const reconnect = () => {
    if (socketError <= 2) {
        clearInterval(heartTime);
        initWebSocket(socketUrl);
        socketError = socketError + 1;
        console.log("socket重连", socketError);
    } else {
    console.log("重试次数已用完的逻辑", socketError);
    clearInterval(heartTime);
    }
};

// 测试收到消息传递
const test = (msg: any) => {
  switch (msg.type) {
    case 'heartbeat': //加入会议
      mitts.emit('heartbeat', msg) // zzk: 触发了一个自定义事件，heartbeat
      break;
  }
}
export {
    initWebSocket,
    websocketonmessage,
    sendMsg,
    websocketonopen,
    websocketonerror,
    websocketclose,
    websocketError,
    resetHeart,
    sendSocketHeart,
    reconnect,
};

```

## 取证平板中实现一个进度条样式

直接复用的钢的代码

```vue<template>
  <div class="fullscreen">
    <div class="loading"></div>
    <div class="text">{{ msg }}</div>
  </div>
</template>

<script setup>
const props = defineProps({
  msg: {
    typeof: String,
    default: "拼命加载中....",
  },
});
</script>

<style lang="scss" scoped>
.fullscreen {
  position: fixed;
  top: 0;
  height: 100vh;
  width: 100vw;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  font-size: 20px;
  background: rgba($color: #000000, $alpha: 0.5);
  z-index: 99999;
  .loading {
    position: relative;
    width: 150px;
    height: 150px;
    border-radius: 50%;
    margin: 100px auto;
    transform: rotate(360deg);
    animation: rotate 45s infinite linear;
    &::before {
      position: absolute;
      content: "";
      top: 0px;
      left: 0px;
      right: 0px;
      bottom: 0px;
      box-sizing: border-box;
      border-radius: 50%;
      border-top: 3px solid #409eff;
      border-left: 3px solid #409eff;
      border-bottom: 3px solid transparent;
      border-right: 3px solid transparent;
      transform: rotate(720deg);
      animation: rotate 3s infinite ease-out;
    }
    &::after {
      position: absolute;
      content: "";
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      box-sizing: border-box;
      border-radius: 50%;
      border-bottom: 7px solid transparent;
      border-right: 7px solid transparent;
      border-top: 7px solid #fff;
      border-left: 7px solid #fff;
      transform: rotate(720deg);
      animation: rotate 3s infinite ease-in-out;
    }
    @keyframes rotate {
      100% {
        transform: rotate(0deg);
      }
    }
  }
  .text {
    position: relative;
    color: white;
  }
}
</style>

```

然后还需要使用部分原生js来将这个组件挂载到虚拟节点（VNode，我也不知道是什么）上：

```js
//      引入创建虚拟节点和渲染方法
import { createVNode, render } from "vue";
import loading from "./loading.vue";

//      定义一个div容器
const div = document.createElement("div");
//      将定义的容器添加到dom上
document.body.appendChild(div);

class loadingObj {
  constructor(msg) {
    const vnode = createVNode(loading, { msg });
    //      调用渲染方法：将虚拟节点渲染到dom中
    render(vnode, div);
  }

  close() {
    render(null, div);
  }
}
export default loadingObj

```

实现取消的原理是： 

父组件（视图）引用子组件（进度条）
子组件内定义事件，触发事件被父组件捕获；
## vue3中向子组件传递数据

## 向组件中传递数据
在setup中加入，然后就可以像使用其他的 ref一样使用了。
React的用法其实跟他挺类似的；

```js
const props = defineProps({  
  msg: {  
    typeof: String,  
    default: "拼命加载中....",  
  },  
});
```

## vue3中使用 pinia获取全局的路由对象

vue2中的选项式api可以通过this获取到router实例，但是vue3里面的组合式api是放在setup函数里面的，所以就用了下面这种方式。

```js
// 如果使用钢的前端模板
const router = useRouter()

const clickNext = () => {
	router.push('/next')
}
```

## axios基本使用
参考 钢的使用。
定义 axios服务：
```js
import axios from 'axios'  
console.log(import.meta.env.VITE_API_URL);  
var baseURL = import.meta.env.VITE_API_URL  
// 创建一个 axios 实例  
const service = axios.create({  
    baseURL: baseURL, // 所有的请求地址前缀部分，在文件env.dev或者env.pro里面  
    timeout: 60000, // 请求超时时间毫秒  
})  
  
// 添加请求拦截器  
service.interceptors.request.use(  
    function (config) {  
       return config  
    },  
    function (error) {  
       // 对请求错误做些什么  
       return Promise.reject(error)  
    }  
)  
  
// 添加响应拦截器  
service.interceptors.response.use(  
    function (response) {  
       const dataAxios = response.data  
       return dataAxios  
    },  
    function (error) {  
       console.log(error)  
       return Promise.reject(error)  
    }  
)  
export default service
```

返回 axios的Promise对象
```js
import request from '@/utils/request'  
//登录  
export function PasswordCheck(data) {  
    return request({  
        url: '/login',  
        method: 'post',  
        data  
    })  
}
```

## pinia的基础使用

定义user
```js
import { defineStore } from "pinia"  
export const useUserStore = defineStore({  
    id: "user",  
    state: () => {  
        return {  
            login: localStorage.getItem("login") ? localStorage.getItem("login") : '',  
            rotateFlag: false,  
        }  
    },  
})
```

## vue3计算属性
```js
const getLen = computed(()=> {
console.log('计算属性执行了');
return arr.value.length;
})
```

## 使用v-for遍历对象

如果要遍历后端传来的json中的所有的一级属性的话：

1. 遍历出来所有的字段：  `(value, field) in user`
2. 通过 pinia设置全局字典；
3. 通过 v-for指令渲染


## css控制最小边框大小

通过 min-width或者 min-height 这两个属性来限制最小值。

## 文字溢出
第一个隐藏溢出的文字，以下的css：
```css
.item-value {  
  width: 170px;
  white-space: nowrap;  
  overflow: hidden;  
  text-overflow: ellipsis;
  font-size: 18px;  
}
```

第二个是使用 word-breaker 属性来进行换行：
```json
.item-value {
  word-break: break-all;
}
```

## vue3 hook

常用的是：
onMounted：页面DOM元素挂载后执行；
beforeRouteLeave：使用router离开的时候，例如使用 router.back() 或者 router.go() 之类的方法

## 消息弹出框

使用 ElMessageBox.confirm 会返回一个Promise
示例代码：

```vue
<template>
  <el-button text @click="open">Click to open the Message Box</el-button>
</template>

<script lang="ts" setup>
import { ElMessage, ElMessageBox } from 'element-plus'

const open = () => {
  ElMessageBox.confirm(
    'proxy will permanently delete the file. Continue?',
    'Warning',
    {
      confirmButtonText: 'OK',
      cancelButtonText: 'Cancel',
      type: 'warning',
    }
  )
    .then(() => {
      ElMessage({
        type: 'success',
        message: 'Delete completed',
      })
    })
    .catch(() => {
      ElMessage({
        type: 'info',
        message: 'Delete canceled',
      })
    })
}
</script>

```

成功和失败改用 ElMessageBox.alert代替。 


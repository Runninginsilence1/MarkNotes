[来源](https://www.bilibili.com/video/BV1Fm4y147Hc/)

# 原理相关
## （网络数据）包的流转路径
是指在不同的网络协议上，这些数据包的状态，以及是怎么进行传输的。
最常考的tcpip协议是在传输层（高层是应用层），底层是网络层。

上面这些是osi模型，是每个计网程序员都要知道的东西。（至少要知道。）


下面这里，首先不管怎么样，一个数据包是需要在多个主机上进行跳跃的。
那么从destination怎么确认呢？是通过路由来确认的。

在发送ip包之前，会把**目标ip和本地路由表进行比较**。
在terminal中（linux bash下，不是windows，下面不再强调）可以通过 `ip rule`这个命令来查看相关的路由规则。

它的规则是一条一条的，每个规则包含有多个字段：
XX：是一个数字，数字越小优先级越高。
lookup xxx：表示搜索哪个路由表，一般会是1~252之间的一个数字，或者是一个string
scope link 表示要发到哪个网段去。

还有一条命令： ip route 似乎是查看具体的ip策略， 


可以学到不少和文件系统以及网络相关的东西。（应该）
# 配置远程编译环境
学习之后，你可以使用**goland直接通过ssh在你的云服务器上运行程序**；你可以通过**goland在终端上调试程序**。

下面开始：
不同的语言的配置应该区别比较大。
我反正使用jb的软件这些；

**远程编译**就是：在本机电脑上写好代码，然后在远程的Linux服务器上调试和运行。

首先是把go的编译环境配置成下面这个样子，在goland中设置：
![[Pasted image 20230617151158.png]]

其中go版本那里暂时不管，用默认的

哎呀你有需要就去看一次视频吧。

goland编译后有一个默认名字，要换掉的话：
![[Pasted image 20230617151800.png]]

这样你本地的项目就可以直接在ssh上运行了！


## 在远程上调试go代码
因为我安装了zsh的缘故，所以有一些相关的问题需要解决。


# 新命名空间内运行程序
首先是Linux中namespace的概念：
首先我的初步结论的是：
Linux中**隔离本身就是目的**（虽然有点绕但是事实可能就是这样，操作系统层面可能有各种各样的原因需要进行隔离），而代码使用namespace进行隔离的时候，一般是为了不同结构中名称相同的元素发生冲突，是为了更好的组织代码，隔离只是一种手段。不知道我这么理解对不对。

GPT认可我的解释。
OS层级下实现隔离可能会有安全性、独立性之类的考量。
隔离最重要的作用（不管是linux还是编程语言的名称空间），应该都是需要**彼此隔离的两个对象都是互不影响的**。


不执着于搞清楚这个概念了。

总之Linux对于这个东西有一种原生的支持，包括：
![[Pasted image 20230628144800.png]]

隔离级别本身的效果，通过示例的demo代码已经体现；


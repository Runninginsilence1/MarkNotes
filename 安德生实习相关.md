 # 安德生实习相关
他们用的c#和.net平台，数据库软件使用的是SQL Server。
我准备把我的笔记都记录在这里。

两个相关的github的链接：
[应该是路线图](https://github.com/kamranahmedse/developer-roadmap)
[AspNetCore的路线图](https://github.com/MoienTajik/AspNetCore-Developer-Roadmap)

看完第一节视频，我只觉得要学习的东西有好多...


# Csharp基础知识，我没看完
首先对他做一个简单的介绍
它是一种通用型的语言，就和其他通用型的语言一样，啥都能做
他是类型安全的
和Java一样，他完全支持面向对象特性

它的目标是生产力，所以它的简洁性表达力和高性能都不错

c sharp这门语言本身是与平台独立的， Dot net只是它的一个运行时，他也可以脱离他。

C#的面向对象的特性
它具有统一的类型系统，跟Java类似
并且它的类型也包括函数

跟Java一样，它的基类也是object，这里弹幕有提到C#中指针不继承自，Object
一句话总结，他跟Java是很类似的，不过在Java中包含有基本的数据类型，这一点跟C#应该有点不一样

它有类和接口，跟Java一样接口是为了避免，直接的多重继承而出现的，他只描述对象的行为，而不提供具体的实现

C#中，类它包括属性方法和事件前两个我知道，事件的话它也是方法的一种，它简化了对对象状态更改的操作，我的理解就是set或get等

C#借用了不少函数式编程的特性。
函数可以当做值来传递，C#通过一种叫做委托，英文名是delegate，来把函数传递进其他

并且还支持一种叫做purity的模式，它的特点是一个变量的值，一旦确定之后就不再发生改变，类似于rust中的不可变类型

C#能方便的支持响应式编程

关于类型安全
一般来说它是静态类型
不过他支持通过dynamic关键字来添加动态类型，这使得他拥有了一部分动态语言的特性
不过总体来说，他还是静态语言
这一个以后再说

关于它的内存管理
它依赖运行时来执行自动内存管理，和现在流行的高级语言一样。
CLR英文全称common language runtime，公共语言运行时，它包含有垃圾收集器，可以回收已经不再使用的内存资源。

C#有指针，但通常不需要用

关于跨平台
C#现在是跨平台的。

介绍一下CLR
他与具体的语言无关
C#是一种托管语言，它会被编译成托管代码，英文简称是IL，不知道这是不是类似于Java的class字节码。
然后CRL会把ll转为可以直接运行的机器码

C#前景不错。

基础知识
首先需要安装对应的环境，
类似于Java的jdk，你需要下载Dot net core SDK，在谷歌上搜索，然后下载
然后就是你需要一个ide选择vs code就可以

关于帮助你可以输入dotnet --help来查看帮助

要建立一个控制台应用的话，console可以

创建一个最常见的控制台程序，可以通过dotnet new console --name hello-world

其中console表示创建一个控制台程序，name是指定待会要输出到目录的名字，如果不填，那默认为当前的目录；

另外这里弹幕提到了framework，默认主要支持windows平台，而核心则是跨平台的，但它不完全包含framework的特性

关于核心
它包含一个公共语言运行时也就是CLR，还有一个标准库，应该说是叫标准库，它的全称是framework class library，

如果你要运行一个刚刚创建好的C sharp控制台程序，在项目的根目录里面，通过view的命令就可以编译。构建成功之后呢，使用donut run就可以运行。
要运行，这个控制台项目呢，你使用让秘密的位置，它必须有那个CS project文件

那么跟其他编程语言不一样的是seashell他飞得特别一点，它的入口文件他不是叫main，他是叫program

似乎在C#里面操作符也就是说加号乘号这些，它也是函数方法的一种

嗯C#有名称空间的概念。现在暂时把它理解成组名是可以的，以后会细讲

using关键字就是使用，另外一个命名空间里面的内容

Donate使用的第三方库，他那里名字叫做nuget，我以前好像在哪下过，相当于一个仓库，类似于 rust的crates.io，GO语言使用的github或者是Java用的maven

如果你的项目中引用了这些第三方库的文件，那么为了运行这个程序，肯定是需要把这些三方库的代码或者说内容先下载下来的。他有一个restore命令来重新下载这些文件

所以一般一个程序或者说项目源代码，它的过程就是restore build，最后run，嗯，测试的环节应该是放在build之后

关于编译这个过程呢，C#会首先把CS结尾的源码文件把它编译成assembly，它是核心里面包装和部署的单元，它可以是应用程序，也可以是库分别对应的后缀名是exe和dll
其实一般只有后者，前者几乎没有

编译后那个对应的文件，它在并也就是二进制文件夹里面的，反正就在那个里面也对了，现在没有必要把这个目录结构分析的很清楚

还有一个OB J文件夹里面存放的是临时文件，可以帮助我们构建应用程序


这节课继续讲基础知识
标识符就是俗称的名字，这个我知道
一些保留的关键字不可以用来作为标识符，如果你真想用他们的话，意思虽然不推荐，你可以在他们里面前面加一个at的符号
例如class @class这就是命名了一个类，它的类名叫做class

C#还提供了一种叫做上下文关键字的东西，他们在不同的上下文中有不同的含义，但他们又不是保留字，这个以后再说

字面值，这种在rust和Python里面提到得比较多。
就是字面意思，比如说数字，比如说加减符号这些，这都是字面量，你一看一眼就知道他们的含义

下面来讲一下C#的类型
类型代表一个词的蓝本，比如说一个数字类型，它就代表是一个数字，一个字符串类型，代表的就是一个字符串

变量是一个存储位置，它在不同的时期可能表示不同的值。而常量永远表示相同的值

加一个const的关键字就表示定义了一个常量

C#里面包含有字符类型，也就是char

Class里面的方法通常被叫做函数成员

关于构造函数与实例化，如果是预定义的类型，他支持直接通过写字面值就，实例化

而自定义的类型需要通过new操作服务，再调用对应的构造函数来创建实例，这一个跟Java是一样的

构造函数的话，是用来构造实例的，所以他不需要写返回值，而实际上它的返回值就是实例

static表示静态成员，跟Java是一样的

并且与Java不同的是，C#可以有独立的静态类，它里面所有的成员都是静态的，比如说system包里面的console类

某种程度上，静态类可以被单作为单例模式的一种实现。

关于访问权限，使用public可以把成员暴露给外部

很多的基础知识。。。和其他编程语言是一样的。。。

琦玉老师的位置是：p4位置


# CSharp创建类型
创建类型

嗯，不知道是不是我前面错过了什么东西，他这里提到了class是一种最常见的，引用类型
它前面可以加上不同的关键字来修饰

这里表示负类跟接口的符号好像是冒号

Class里面的字段，英文是field，它可以添加一个read only修饰符，它是为了防止字段在构造之后被改变，直接翻译就是只读的，他只能在声明的时候被赋值或者在构造函数里被赋值

弹幕这里提到了有一个动态指读和静态指读的概念，暂时记录在这里

关于字段的初始化
字段可以可选的初始化，如果没有被初始化的话，他会有一个默认值，

先后顺序，字段的初始化在构造函数之前运行

C#里面可以通过逗号来同时声明多个字段

同时要求类型类的方法签名必须唯一
啥叫方法签名？它就是指方法名和参数类型，包括它的顺序，但是与参数的名称和返回类型无关。

比如说你定义一个叫做get age的方法，那他的名字和参数顺序，在这个类里面它就是唯一的了，不能再出现同一个方法跟大家同一个名字，并且参数的类型和顺序和它一样。

cs6终引入了一种叫做expression body的方法。他似乎是某种单语句函数的语法糖

C#里面支持方法重载，也就是方法名不一致

并且和Java不同，C#钟可以指定，在给方法进行传参的时候，是传递的值还是引用
传递引用的话，需要在参数前面加一个ref修饰符，他也是方法签名的一部分。

也就是说C sharp里面默认是按值传递的了

out关键字，似乎也是引用，但不知道，区别是啥

C#7里面，似乎新增了一种叫做本地方法的特性，就是嵌套定义，在函数里面另外定义一个函数，有点脱离本质的意味，嗯，这个不具体关心


# 关于类型的部分
依旧是关于类型的内容
首先是类型转换
C#中互相兼容的类型可以互相转换。
在底层他总是从现有的一个值创造出一个新的值，换句话说，两个东西是不一样的了

C#存在隐式转换和显示转换的区别：
隐式转换是自动发生的，而显示转换需要手动进行

显式转换跟Java是一样的

范围小的可以自动被转换成范围大的

注意即使是强制转换，它也是有条件的，如果编译器判断你的这个转换肯定会失败，那么它会绝对禁止你进行这种转换

C#类型分类
一般来说它分为4种类型
值类型，引用类型，泛型类型参数，指针类型

值类型包含内置类型数值字符布尔值，以及自定义的struct和枚举

引用类型则包括所有的class，数组，委托，接口，也包括字符串。

它们的根本区别在于处理内存的方式。

值类型它就是一个值，是一个固定的量
通过关键字struct可以创建一个自定义的值类型

很明显可以感受到的，一个是，值类型，在进行赋值的时候会复制一份副本。

关于空值，它是一个字面量，表示不指向任何引用

调用空对象的任何属性都会抛出一个空引用一场

值类型它不可以为null

关于这些类型的内存开销
对于值类型而言，它实际所需要的内存就是他所有字段所需要的内存的总和
不过公共语言类型时，会把字段大小设置为实际大小的整数，这一部分是因为有内存对齐的，需要比较难，以后再说
比如说一个结构体大a，它有两个字段，一个是布尔类型，一个是长整形，第1个字段需要一个自己，第2个字段需要8个字节，而他实际上所占的大小将会是16个，自己而不是9个，自己因为对于布尔类型来说，他只使用了一个字节，而他，对应会占用8个字节，这样另外7个字节就被浪费了

引用类型的开销
引用类型涉及到数据和对应的引用，需要把它们单独分配内存
一个对象所占的内存需要，对应字段所占的内存和以及额外的管理开销最少是8个字节
然后他们的引用根据对应平台的不同，32位和64位，他们还需要额外的4个字节或者8个字节

弹幕这里有提到关于这部分额外的开销是什么
类型对象的指针，同步块索引，前者用来处理真实类型的对象，后者用来处理线程同步以及GC的回收标志

在使用时只需要明白字符串和一般对象，他们都是引用类型即可。

这有一部分底层的内容，就是内置类型，它们都位于system命名空间内，除了demical也就是广义的实数类型之外的内置类型被叫做原始类型，他们在底层被直接支持，可以直接应用利于处理器， System明明空间中还包含有intP TR和，无符号的Ptr他们也是原始类型，个人推测，这里可能是C语言的缘故

构造函数和析构函数
参考Java的构造函数

并且前面提到过，由于C#7中引入了，箭头，使得单语句的方法可以直接用一个右向箭头表示，在构造函数中也一样，比如说
public class Panda {
        string name;
        public Panda(string n) => name = n;
    }

并且如果要在构造函数中调用另外一个构造函数的话，你可以使用this，比如说
public class Panda {
        string name;
        uint age;
        public Panda(string n) => name = n;
        public Panda(string n, uint m): this(n) => age = m;
    }



# 委托
关于委托

最经典的描述关于委托，委托是一个对象，他知道如何调用一个方法，
委托有点函数式编程那个味儿，或者说Java中的单方法接口

委托有委托类型和委托实例，
委托类型它定义了一个函数的签名，
而把方法赋值给委托变量的时候，就创建了一个委托实例，换句话说，一个变量它可以存储一个函数

委托的实例其实就是调用者的委托调用者调用委托，而委托调用目标方法，委托是个中间人，相当于中介

这样可以把调用者和目标方法解耦合

委托适合用来编写插件式方法，方法是在运行时才赋值给委托变量的

这里用数组的平方来，举例了一个具体的委托是怎么工作的？厄我觉得代码比较简单，就没把它记在这里了，下面来看其他东西

多播委托
简单来说就是用加号可以，合并委托的实例，比如说你定义一个委托实例，它有方法一，然后它的值可以加上一个方法二，这样再调用这个委托实例的时候，它就会按定义时的顺序先后执行方法一和方法二，

委托可以合并，当然也可以移除，减号操作符就可以
并且空值可以参与到委托变量的计算之中，很容易理解

多播委托的特性，它可以实现设计模式中的职责链模式

关于使用多播委托时，返回值的问题，一般来说调用者只会收到最后一个，方法的返回值，前面的都会被丢弃

委托在底层是有父类的，以和解加号减号操作符也是有对应的方法的，这些编译器都给你做了优化

继续讲委托
首先前面是提到过的，由于面向对象的特性，这个方法它可能有对应的实例成员，也有可能是静态方法，这就，产生了区别，实例方法目标和静态方法目标。

涉及到委托就是，当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留对方法的引用，还要保留这个方法所属实例的引用。 我理解的话，就是这么做的原因上，本质上还是通过对这用这个实力去调用这个方法。

委托是一个对象实例，应该是这样的。他在系统的system包里面，他的target属性就代表这个实例。

如果是委托的静态方法，那么这个属性对应的值就是空

委托类型是可以声明泛型参数的。
C#中泛型的使用比较友好，当可以自动推断类型的时候，是不需要额外写声明的泛型参数的。

泛型委托的用法
使用泛型委托可以写出这样一组委托类型：他们可调用的方法可以拥有任意的返回类型和任意合理的参数。

在底层它们分别叫做func和action
这里有一部分泛型协逆变的内容，不知道我需不需要去补充完
todo

弹幕这里提示到上面说的这两个东西相当于官方给你提供的委托，不需要自己去做实例化，直接拿来用就可以了

委托vs接口
首先终极的结论是，委托可以解决的问题，接口都可以解决。

那么一定就有一种更适合使用委托的情况：
比如说当接口只能定一个方法，或者需要多拨能力，或者订阅者需要多次实现接口的时候，更适合使用委托。这应该是函数式编程的体现接口，属于面向对象范式的概念。

另外关于多次实现该接口是一个什么样的概念呢？
比如说两个类，一个实现平方方法，一个实现立方方法，这个时候其实就是多次实现委托功能的时候。

另外委托类型之间彼此独立，也就是说他们，互不兼容，即使他们代表的方法签名一样。

不过委托实例是可以的，毕竟他们本质上就是一个类型嘛。并且如果他们拥有相同的方法目标，那么就可以认为它们是相等的，可以用双等号判断，结果为真

另外，委托在参数上也有一定的兼容性，也叫做协变或者逆变，这个，到时候说

另外和泛型的类型参数一样，委托的这个仅支持引用转化，这个variance是啥意思啊
也就是说如果是值类型的话，他们如果不支持互转，那是会编译失败的

弹幕里，总结核心原则是严进宽出

# 事件
事件
之前我在安卓里也接触过，它是有广播机制的，不过只是大概看了一下，这次来学习C#中的事件。

在使用委托的时候通常会出现两个角色，一个广播者，一个订阅者

再次重复一下委托，在底层上是一个类，他具有类的一切特质

广播者这个类型会包含一个委托字段，也就是说它的成员变量中有一个类型，这个类型它是一个委托类，广播者通过调用委托来决定什么时候进行广播。

而订阅者呢，就是这个方法目标的接收者，订阅者可以决定何时开始或者结束监听方式，是通过在委托上调用加号和减号。

订阅者之间彼此互不干扰。
以上强调的是委托以及广播，和订阅之间的关系或者说概念，并没有提到事件那事件是什么呢？

事件就是把上述模式正式化的一个语言特性，它是一种语言特性。
事件是一种结构，它为了实现广播订阅者模型，它只暴露所需委托特性的部分子集，也就是说事件算是一种委托在某一个方面的特殊用法。

事件的主要目的就是为了防止订阅者之间相互干扰。

定义一个事件比较简单，只需要加上一个关键字就可以了。
你可以直接看这个代码。

```cs
namespace MyDelegate
{
    // Delegate defination
    public delegate void PriceChangedHandler(decimal oldPrice, decimal newPrice);

    public class BroadCaster {
        // Event declaration
        public event PriceChangedHandler PriceChanged;
    }
}
```

并且最重要的特性就是，在定义这个事件内内部和外部，比如说是一个类class定义的这个事件，对它的访问权限是不一致的：
在内部，可以完全把它当做一个委托来使用；
而在外部，你就只能把它对它进行+=和-=操作，并且弹幕这里提到了，这两个操作相当于关注和取关，很符合起得订阅者这个名字。

事件在内部是如何工作的呢？
它底层的实现似乎是一个私有字段加上对外开放add和remove两个方法。这里琦玉老师没有讲很清楚，所以不管了。

为了使用方便，net还在底层预制了一个专门用于处理事件的基类，System.EventArgs, 是一个预定义的框架类，除了静态的Empty属性外，它没有其他的成员。

他这里准备了一个实际的代码，用于事件进行消息传递的，不过具体是什么意思我是一点都没看懂啊。位置是视频的05:52

这后面就开始看不懂了卧槽...

# 泛型
和Java不一样的是，CSharp的泛型算是真 泛型。这里以后在解释，总之因为语言的诞生年代不同，观念也有些不同。

在C#里面跨类型来复用代码有两种方式。
一种就是继承，第2种就是泛型

第1个是通过定义一个基类的方式。来表达代码的可复用性。

而泛型相当于一个带有，占位符的模板。

而泛型的消费者在使用泛型的时候需要提供占位符所需要的类型。

go语言就没有泛型。
如果没有泛型，想要实现之前不同类型代码的复用，要么就是不同的类型分别实现这样代码量会，成倍的增长。而如果通过使用object的方式，一是会损耗性能，二是转换在编译期间无法进行检查，因为这个只有在运行时候才能出现。

是否是泛型方法和方法是否使用泛型参数有关，和是否为泛型类里面的方法无关。

放行中还可以使用type of关键字。他多和反射的API一起使用。

可以有默认值，通过default关键字来获取泛型的默认值。

默认的泛型可以任何类型的参数，不过，如果你对泛型参数有特定的要求的话，可以加上对应的约束条件。


```cs
where T: base-class  // 要求这个泛型继承指定的父类
where T: interface  // 要求实现对应接口
where T: class // 是引用类型，不知道跟第一个有什么区别
where T: struct // 要求是值类型，并且不包含值可为null的那种类型
where T: new()  // Parameterless constructor constraint 要求无参构造器
where U: T // 这里应该是指定两个泛型参数的关系
```

并且，看起来一个泛型参数好像是对应一个泛型参数来着一样。
```csharp
class GenericClass <T, U> where T: SomeClass, Interface1 where U: new() {...}
```

并且这个约束也可以用在泛型方法中。

关于泛型class的子类：
它可以有子类，在子类里面，可以让父类的类型参数继续保持类型开放的状态（就是不把泛型定死为具体的类型）

也可以在子类里面填充具体的类型，来封闭父类的类型参数；

子类里面也可以引入新的类型参数；

```csharp
class List<T> {...}
class KeyedList<T, TKey> : List<T> {...}
```

至于底层，可以认为子类所持有的父类的泛型是全新的。 可以认为子类把父类的泛型参数关闭了，然后又打开了，就是这样。

泛型类可以进行自引用；
就是泛型占位符的实际类型可以是这个类本身

并且这里还讲了一种有趣的写法，你可以看看他是什么：
```csharp
class Foo<T> where T: IComparable<T> {...}
class Bar<T> where T: Bar<T> {...}
```

弹幕有提到这里的这个，bar的意思是需要实现的子类，似乎是这个意思

静态数据：
如果一个泛型类中声明了一个静态变量，针对每一个封闭类型，静态数据是唯一的。换句话说，静态类型和封闭类型相绑定。

类型转换这里有点没听懂，所以看看要不要，在泛型约束这里，视频快结束的地方。

# 协变，逆变，不变

这里弹幕给的提示我觉得算是非常不错的东西了。


由于一个T既输入又输出，只能让它不变，不然在转换的时候编译器会懵逼；
输出也就是返回值只能向上转换（子 -> 父），返回苹果也可以返回一个水果，反过来不行
而输入也就是函数参数值，只能向下转换（父 -> 子），参数要一个水果，你可以给一个苹果，反过来不行


如果一个泛型参数只是作为参数，那它就用in进行修饰；这被称为 Convariance；协变
如果一个泛型参数只是作为返回值，那它就用out进行修饰； Contravariance；逆变
两者兼具，就不能这样做了。这被称为不变。

这么已解释我觉得很好理解了。

弹幕提到：
协变 逆变 不变 是对泛型参数T的转换约束。防止在实际运行的时候发生不安全的转换。

前面那三种东西统称为 variance，它只能出现在接口或者委托里面。

为什么会这样呢？

当发生前面这些类型的类型转换的时候，我们就可以认为发生了 variance转换。它是引用转换的一个例子。引用转换是指，你无法改变底层的值，只能改变编译时的类型，编译器对它的认知。它的本质是不会变得。

还有一种叫 identity conversion的说法，是在CLR层面，从一个类型转换到一个相同的类型。换句话，就是底层类型一致，就叫这个名字。

并且， CSharp中似乎子类转换成父类，都叫做隐式的引用转换；

装箱操作并非引用转换（值类型到引用类型）

注意，生产类型（例如List\<T\>）可以被编译到dll中，因为他们是主要行为是发生在运行时的。

# SQL SERVER
他们这里主要是跟数据库打交道。如果是这样的话...

## 这里是基本的crud
熟悉这些是有必要的。
这个书应该是有点作用的... 感觉跟教材差不多，趣味性肯定很低。 反正我不是正式员工，风格随意点应该问题不大。 还有我应该是不会在这里任职的，太捏吗压抑了。

## 关系型数据库的一些基本概念
用来查询用。
所以不拘泥与细节。
一行数据如果有这些属性，那就称为关系模式，就是这样：
实体(属性1，属性2...)

主键：用来唯一标识一行（某一个实例的）东西，就是说本质是一个属性。（因为要用来唯一表示所以他是：非空，唯一，很好理解其实。）
联合主键： 多个属性才能作为主键，就这个。

外键： 多个表的某些属性之间建立了联系，比如A表如果引用了B表的某个属性，那么可以说B的这个属性是A的外键，算A的伪成员。主键常常作为外键。

还是以上面这个为例，那这里B就是主表，然后A就是从表。

还是先搞清楚ER是什么“人”吧。

关系型也算是伴随面向对象分析一起发展起来的吧。

实体具有属性，然后属性和其他实体的属性又有联系，这样的。
这里有点歧义的样子：应该不是实体的属性，而是实体和实体之间的关系。。。 这里我要仔细看看：

实体就是一整张表，而属性就可以表里面第一行的字段。只是知道这些有什么难的？

然后就是这种11，1n，nn这种东西之间对应的关系，怎么像数据库表的方向去转换：

1n：比如学生与专业： 学生是n，专业是1，那就在n的这方面添加1方面的一个主键就可以了。 这样两个表之间就可以建立联系。 

nn：那此时一个主键显然就不够用了，所以需要用额外一个关系表就来存储两个表之间的关系。

11：同1n，都可以。

然后这些1n和nn或者11之间最好理清是一种什么关系，然后 实体之间用一个菱形表示：菱形：学习，这个就可以代表学生和课程之间的关系。


范式
现在回顾这些东西感觉其实轻松的，如果需要的话，现在头脑停不下来咯！

范式就是对应的设计某种东西的规范，比如面向对象就是一种范式，面向过程也是一种范式，函数式编程也是一种范式。

对应数据库这方面来说，统一称为第一、第二、第三范式，一般的数据库设计需要满足这三个范式；

第一范式就是：字段不可再分割，原子性。 具体情况以后再说。

第二范式就是：一个实体对应一张表，然后有主键，可以标注每一个实例。 这个特性可能叫做唯一性...

第三范式： 外键只能是其他表的主键。 这个应该是保持实体与实体之间关系的纯洁，哈哈我在说什么呢。

一般来说满足第三范式就足够了。

## 关于sql语言本身
Transact-SQL，如果看书上的理解是，就是ms sql server所使用的的sql语言的方言；
尽管我学习过mysql，不过还是不同方言之间的差异可不小，所以需要来再次回顾一下。

回顾：sql语言，根据他们的具体功能，可以分为四种（名字不用去，虽然也不难记。）
ddl：用于管理数据库或者数据库对象，比如表的创建，表结构的修改，表的删除；

创建表的话，一般需要考虑表名，字段相关的，

首先用create database 数据库名称，这样的格式来创建一个数据库。

```sql
create database SchoolDB; -- 就是用这个创建数据库的
use SchoolDB  -- 切换到这个数据库
Go -- 这个go真是显得有点莫名其妙的

create table Tstudent (
    字段的相关信息...
)
```

修改表的结构，如果有这个需求，通过alter修改表的结构；
```sql
alter table 表的名字 你要对表的结构做什么修改，后面接上类似创建表的时候字段的格式
```

一些其他的东西方面的，有需要就接着来这里查询，应该查ddl就可以了。


dcl语句，我好像没接触过。
类似于面向对象的权限管理，主要是适用在权限控制：
有三种： GRANT(允许权限) DENY（拒绝权限，比grant权限高，相当于grant之后如果有deny，那么实际上是后者会生效。） REVOKE（移除前面的两种权限。）

过程是： 授权者 在 哪个容器上（table; view; index）上给予权限给被授权者。

根据这里的例子：允许（或拒绝） 谁（例如public）对 哪个表（table）的 什么（alter或delete）权限。

例如：
grant alter on Tstudent to public
这句话的意思就是允许 public 对 Tstudent 的 alter权限。
deny同理。

使用revoke可以回收权限。暂时用不到，就不写了。

dml语句：就是crud了。
这里记住，前面的ddl是对表结构操作，对比oop，就是修改类；
dml这里就是修改具体的某个实例。

插入语句：
给哪个表的哪个字段，插入哪些数据： 
insert into 表面(字段...) values (具体的数据)

以上是定义的sql标准；
T_sql这个省略了into，并且在values这里可以用逗号分隔多个括号，这样就可以用一个语句插入多行的数据；


update语句：
更新过程是：修改哪个表的，哪行数据的，哪个字段值
update Tstudent set 字段= 然后 where一般是用来执行主键。

通过where来指定行；如果不写where的话，就对所有的行的对应字段进行修改。

select 查询的知识点多
select * from table_name;
从哪个表里面查询哪个数据；

select指定字段，然后通过as加载表中的字段的后面，可以为查询结果（一个表）起一个别名，更加方便。

delete就是删除某一行数据了：
类似的原理。

以上的内容是标准的sql标准，然后下面的一些是 T_sql的特有要素：

批处理符号go
这个关键字可以通知sql执行器把一个批处理里面所有的sql语句一次运行。 现在的问题是，这玩意是事务吗？

现在暂时把他当成mysql的事务符号来进行处理。

这个go符号感觉还挺绕：
首先用go分割的语句，只要有一句失败，那么其他的语句的执行也不会成功。

第二：用go分割的sql语句是才能成功运行先建库后使用的操作。

这里最好去看ms官方的文档，或者说自己测试，得到结论。

exec关键字：用于执行某个函数或者存储过程，我觉得也类似于批处理的的样子。

在某些情况下可以省略exec关键字。

关于标识符：
就是所谓的变量名之类的东西。 T_sql中某些符号具有特殊的含义：
例如@符号开头表示全局变量；单#符号开头表示本地临时表和存储过程；## 表示全局临时表。

他们有不同的特性，有需要时再去查询。

还有分隔符，类似于编程语言中双引号，就是用来表示语义的；
比如这里可以是： 中括号和双引号。 


数据类型可以回顾一下，不过现在暂时没有必要看。
其实主要就是整型浮点型这两个，还有varchar这些东西。


基础算是过了一遍了。。。不过这个内容可不少，现在我已经暂时不想去看了。 

**T_sql里面常用的函数：**
聚合函数
count()，计数函数
Avg（）平均数；
sum（）汇总；...
并且除了count之外，这些函数都对null做忽略处理；这很好理解。


精度处理相关的函数：
round（value，n）；四舍五入处理
floor（）小于的最大；
ceiling（）同上，这个单词就是天花板的意思

并且关于这个round函数，就是四舍五入对n对应的位置，不过不会实际“丢失”精度，因为这个值被处理了。

round(125.45, 2) -> 125.45
round(125.45, 1) -> 125.50
round(125.45, 0) -> 126.00
round(125.45, -1) -> 130.00

其实只要看懂这个-1的意思那就好说了。

另外常用的还有一个取随机数的函数。
rand()他提供的原始功能是： 每次取0~1之间的，不包括0和1的随机值； 并且每次的取值可以保证和上一次的不相同；
如果要扩大范围，那么只要将范围一并的扩大就差不多，比如 乘以100之后，范围就会变成0~100，很好理解。

如果想要取到单边边界的整数值，配合上面的地板和天花板函数即可。

而如果是双边界，那就考虑拓宽边界，例如 0~101 -> 就可以取到0到100之间的数了。

关于字符串相关的函数： 这个以后用到的时候再考虑，毕竟函数名就可以解释函数的作用了。
实在要的话就在书的29页里面。

这些函数的话。。。虽然常用，但是毕竟不是核心的功能。

关于null的处理，我以前没有接触过这个，来看看他的作用：
nullif(a, b)：
if a == b return null;
else if a == null throw NullRefException;
else return a;

coalesce()，我不会读，没办法，意思是合并，作用是：
coalesce(v1, v2, v3...)
打印第一个非空值，如果全空就报错；

isnull（），吐槽这三个函数都不是字面意思
这个的作用是：
isnull(v1, v2) 等价于 v1 == null? v2:v1;

然后是sql内置的流程控制语句...
暂时也不想看，如果有需要转到书33


# 查询
查询是个重点，这里可不能随便跳过了。
首页对于查询来说，并非简单的所见即所得，你的sql语句会经过sql_server的优化，大概是这么个意思。 所以到时候需要debug的时候这个过程你也是需要清楚细节的。

首先一个sql语句中涉及到多个处理过程的时候，没完成一个阶段的计算，都会产生一个对应的虚拟表，这个就是所谓的中间代码，代入编译原理的知识去理解即可。

一个sql语句的执行顺序；
对于一个基本的查询语句来说（这里不写书上实例的sql语句），它的执行顺序是：
第一阶段： 通过FROM来确定是查询的哪个表。
二： 确定where来筛选数据。
三： 给数据分组，group by。对了，关于这个分组，是根据by指定的这个属性值，值相同的就分在一起，大概是这么个逻辑。
四：就是select的逻辑了；至于为什么select在最前面嘛，这个就相当于编程语言里面的函数嵌套调用；
芜~~~~~：这个部分就是 order的那个了，给数据排序。

并且这里有having，它的顺序在group后面select之前。

是的，并且理解具体的执行顺序有个很大的作用：就是可以帮你快速定位到错误。

比如这里有一个经典的：
select data as 我是别名！ from temp_table where 我是别名！=多少多少，这里就会报错；
因为别名是在 select阶段定义的，而where阶段在 select前面，他此时还没有被定义。


数据库对象的引用规则：
先回忆一下：数据库对象可以理解为某个数据库里面的某个具体的表；
完整的引用格式为： database_name.schema_name.object_name; 
即数据名点架构名点对象名； 这个我暂时用不上。

select用于筛选列；
where用于筛选行；
between...and...用于检索范围里面的值； 同义的还有 大于小于号以及NOT关键字。
In可以用于将条件限定在一个枚举类型里面：比如 sex IN （'男','女'）

like则用于模糊匹配，类似于通配符或者正则表达式的匹配：
知道这些：%代表任意字符串： 郑% -> 郑子康，郑说的道理；
\_代表任意字符串： 郑\_ -> 郑子，郑说；
中括号为指定范围的，里面加个^的话就是不在这个指定范围了，我推测是不是跟 NOT \[\]类似？ 哦是的，not like就可以；

在遇到与控制有关的运算时尽量使用null函数，而不是自己造的轮子，因为要保证性能。

保证查询性能的要点：
不要用求反，因为相当于拆开成两步；
不要用like，因为模糊查询会降低性能；

格式化结果集
结果集就是查询结果，就是一个给用户看的表。
查询结果里面可以添加常量、函数和表达式。
常量： 比如说 select ..., '我是常量' as 常量列
函数不用说；
表达式：
表达式的话要用一个case关键字，相当于一个小型函数这样。里面写的表达式，表达式可以计算出结果。

别名可以使得过程变得更加友好
表（table_name）列（select后面的内容）计算列（表达式或者函数返回值）表达式（呃，这个我就不清楚了）都可以定义别名。

有三种方式定义别名： as、空格、使用赋值符号等于“=”号

赋值符号的类似： date=getDate()这样的；

在使用别名的时候主要有两个要注意的地方：
一个是，如果给表定义了别名，那么后面使用这个表的时候，它的标识符都要是别名，不能是原来的表名了。 知道吗。

第二个，其实之前已经提到过了，就是说你必须要先定义后使用，这个就要求你搞清sql的执行顺序了；

关于排序：
order by可以用于排序，默认为升序：asc；也可以按降序排列desc。
排序是在select之后进行排序的，所以他可以引用select设置的别名。

外连接（外联接）
多表的本质的是通过笛卡尔积来联立数据，内连接是通过where（应该）筛选条件，如果不包含条件则不返回。所以当某一行数据都不满足两个表的筛选条件的时候，该行数据就会被忽略。 现在需求是不忽略这个数据，这就是外联结需求的由来。

外联接会保留from关键字里至少一个表的所有行。 这个表被称为保留表。

虽然我不知道为什么要特地因为保留表跟join关键字的位置的相对关系来区分啥叫左连接和右连接... 还有一种全连接，就是全部保留。

这里还是慢慢从联接看起：多表联接。 它最开始的内容是内连接。

联接的关键字是join和on，他们 通常在 from的部分，那就是说有特殊情况了。
语法就是 
from 表1 join的类型 表2 on 后面接条件，也就是说这个on是可选的。

这个的join的类型由三种： 交叉、内、外，如果不写 on，默认是交叉。

这一下就来了： 除了from（从哪个表里面）where里面也是可以写联接的； 比如说 Tstudent.StudentID=Score.StudentID

区别在于， where它只支持交叉和内连接。 实际上这个是早期的写法，现在统一规范用join关键字。 记住就可以。

交叉联接就是所谓的笛卡尔积...我觉得我一直以来的理解有问题。

而内连接就是经典的条件筛选： 先获得笛卡尔积，然后经过条件筛选得到结果。 用on关键字来制定条件。

并且在使用内连接的时候，通常推荐设置别名增强可读性。

这里我插两句嘴： 就是原来我认为的内连接是这样的：
select * from table_1 join table_2 where table_1.ID=table_2.ID AND table_1.depart='xxx'，我以为是这样的；

现在看来是吧连接条件写在on那里，在where的前面，这个算规范写法。

并且， T_sql这里，的优化器，它会吧on和where的部分一视同仁（不难理解，本来就是一个逻辑），不过在外联接中，因为保留表不同的缘故，此时这两个就有先后顺序了，这个还是挺好理解的。

感觉挺容易的。 现在来看外联接：
内连接中，如果不符合条件的数据将会被排除。 现在有需要，需要保留某个表的数据，即使是它不符合条件。 这个我前面写了一些笔记。

外部行这个名词就是来描述不符合条件，但是又在保留表里面的数据；
很符合外部这个名称。

这个左右他妈的就是一个意思，那我不管了。

这个完全查询也是字面意思。 肯定还有我不知道的东西，不过我现在暂时不管了。

外连接这里需要关注的主要是 on和where的执行顺序的问题。 需要先筛选where的条件，在关注保留表是哪一个。

上面讲的这些内容仅仅是两张表进行联接时候的情况。 在复杂的业务中，需要大量的表来进行查询。 此时基本的逻辑是两张表的查询结果作为虚拟表来与下一张表进行查询。
根据这里的联立的顺序的不同分为顺序和类似于函数调用的那种嵌套。
这里可以看书的64页面；
总之记住： join表示联接哪两个表， on表示筛选东西的条件，他们如果不在一块，那就是嵌套连接。 记住这个就差不多了。

关于union关键字：
首先最简单的一个总结： union可以认为是对结果集（查询结果，真姬八拗口，我后面还是用查询结果来描述好了）的追加，是对行的追加。

比如两个 select就可以通过union连接在一起： select id, name from table_1 union select id, name from table_2;

这里插一句嘴，好多都是一些细节，不代入到具体的实践里面去学习的时候真的好无聊。 所以看完这一部分我就去看代码;

联接是相当于横向相加，而合并相当于纵向相加。



对了，我把数据库相关的东西给弄进来，看看具体的。
现在要看的话，就是考虑编写注释边看，然后就对应有什么知识点再去学习就差不多了。

T_sql：
```sql

-- 好好好
select 
		 AA.BillNo
		,CC.BillTypeName 
		,AA.StockName
		,AA.RefObjectValueName 
		,AA.AuditName
		,AA.AuditDate  
		,bb.MaterialID
		,DD.MaterialCode 
		,bb.MaterialName
		,bb.MaterialSpec 
		,bb.ManufacturerName
		,bb.SupplierName
		,bb.Barcode
		,bb.LotNo
		,BB.EffectiveDate
		,BB.ProduceDate
		,BB.InDate
		,BB.Quantity*BB.InOutFlag AS Quantity
		,BB.CurStkQty 
		,BB.Unit
		,BB.UnitPrice
		,BB.Amount*BB.InOutFlag AS Amount
		,RqH.BillNo  AS ReqBillNo
		,RqD.SubmitDate
		,RqD.SubmitUserName
		,MT.MaterialTypeName
	from Stk_Movement AA -- AA，是给这个 Stk_Movement设置的别名，就是不明白为什么起这种名字，毫无美感。
	left join Stk_MovementDt BB on aa.BillID = bb.BillID -- 通过主键进行联接，顺序，下面为了省略用S（顺）表示；
	left join Stk_RequestDt  RqD on RqD.BillID= BB.ReqBillID And RqD.BillRowID=BB.ReqBillRowID -- 算了，不啃这些具体字段的含义，效率低，浪费时间
	left join Stk_Request    RqH On RqD.BillID=RqH.BillID 
	left join Dic_BillType CC on aa.BillTypeID=CC.BillTypeID
	left join Dic_Material DD on BB.MaterialID=DD.MaterialID
	LEFT JOIN Dic_MaterialType MT ON BB.MaterialTypeID=MT.MaterialTypeID 
    -- 从这里继续
	where   
		AA.StockID =@StockID -- 这里需要StockID为某个常量；
		--and AA.AuditDate between @StartTime and @EndTime 
		and AA.InOutFlag in (1,-1) 
		and BB.StockMethodFlag=@StockMethodFlag
		and (@MaterialID='' or BB.MaterialID=@MaterialID)
		and  MT.MaterialTypeID in (SELECT * FROM [HRP07].[dbo].[fun_GetMaterialTypeIDTable] (@MaterialTypeID))
	order by AA.StockID,BB.MaterialID,AA.AuditDate,BB.BillRowID  
```



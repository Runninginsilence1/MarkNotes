# Go 并发

# Goroutine
**Goroutine的三种用法**
```go
//go 关键字放在方法调用前新建一个 goroutine 并执行方法体
go GetThingDone(param1, param2);

//新建一个匿名方法并执行
go func(param1, param2) {
}(val1, val2)

//直接新建一个 goroutine 并在 goroutine 中执行代码块
// 这种好像在 go 1.18中不可用
// go {
//     //do someting...
// }
```

一个 goroutine必定对应着一个函数。
**绑定goroutine的时候，该函数的返回值会被忽略，请使用 channel**

goroutine小细节
> 所有 goroutine 在 main() 函数结束时会一同结束。
goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。
终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。虽然可以用 golang.org/x/net/context 包进行 goroutine 生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。
截止 Go 1.9 版本，暂时没有标准接口获取 goroutine 的 ID。

有办法可以获取 goroutine id，但是这种做法就像 C++编程一样危险。一般不向外部暴露。



# Channel
## 并发编程的复杂性
并发编程的**难度在于协调**，而协调就要通过交流，从这个角度看来，并发单元间的**通信是最大的问题**。
在工程上，有两种最常见的并发通信模型：共享数据和消息。

锁的使用比较直观，但是写出来的代码臃肿不堪且难以理解。

Go使用另外一种通信模型，消息机制。（顺便一提安卓的原生并发也是使用的一个handler的消息机制）
> 消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。这有点类似于进程的概念，每个进程不会被其他进程打扰，它只做好自己的工作就可以了。不同进程间靠消息来通信，它们不会共享内存。


## 
> channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go语言对于网络方面也有非常完善的支持。

个人理解：channel的传参和函数有点类似，引用传递的话也是用指针。
并且一个channel对应一个类型（类比 Unix的管道），可以**类型安全**


# Go 程序员面试笔试宝典 笔记
# 数组与切片
## 数组和切片有什么异同
这么久了我看到的最好的一个对于切片的定义: 
> slice 是对数组的封装(抽象)，它描述一个数组的片段。
> 切片要比数组灵活得多，因为长度是数组类型的一部分。

slice.array指向的**底层数组可以被多个切片共同指向**, 所以注意. 

## Slice的扩容机制
引起 Slice扩容的函数是`append`函数。
它的参数可变，也可以通过传入 Slice...的方式直接append一个切片。

调用 append函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。（这是规定，不过其他函数就不一定了。）

使用append时如果slice发生了扩容，那么：
1.18版本以前：
> 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。

1.18版本：
当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4。

通过作者分析源码（我自己看不懂）
```go
// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		// ……
	}
	// ……
	
	capmem = roundupsize(uintptr(newcap) * ptrSize)
	newcap = int(capmem / ptrSize)
}
```
顺便解释一下 threshold是临界值的意思。
在超过上面里面提到的大小之后，go会进行内存对齐，所以新的容量总是大于等于 上面规律的大小。

slice发生扩容的时候，调用 growslice函数，里面有一个参数cap（表示如果要完成扩容所需要最小的容量）
函数内部会将 old.cap 的两倍和 这个cap进行对比，取大的那一个。

继续看


# 哈希表
就是字典. 

底层的数据结构一般是 哈希查找表(数组 \+ 链表) 和 搜索树. 

哈希查找表一般会存在“碰撞”, 解决办法 一般就是挂链表和开放地址法(按照某种规律重新选择一个位置存放). 

平衡树(avl树, 红黑树)的原理和实现都比较难...所以...

自平衡搜索树法的最差搜索效率是 O(logN)，而哈希查找表最差是 O(N)。

并且, 前者是有序的, 后者往往是无序的. 

## go的实现

# 草稿区域

> Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。 

# go的gc
## 垃圾回收的简单介绍
gc（Garbage Collection），就是编程语言提供的一种用来进行**内存回收**的方式。
区别于c和cpp，引入垃圾回收可以让程序员回避内存管理的复杂问题，但同时由于引入gc会导致stw(Stop the world)等问题，所以性能一般不如手动管理内存的语言强大。

gc的流程其实十分简单，因为就是两个：
1. 谁是垃圾？
1. 那我要怎么回收？

所以gc一般可以分成两个**半独立的组件**：（这里之所以说半独立是因为只单独让他们一个生效没什么意义应该。）
1. Mutator: 赋值器：对于GC而言，用户对代码所做的改变，就是**修改他们的引用关系**。
1. Collector：回收器，负责进行垃圾回收。

## 根对象
根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时**最先检查的对象**。
整个扫描的顺序**应该是多个不同根对象的树结构**
以Go语言为例：
1. 全局变量是根对像：一个全局变量的生命周期通常与整个程序同步。
1. 每个goroutine自己的调用栈。如果你知道Java的gc的话那么应该也知道这个。
1. 寄存器里面保存的指向的根内存对象中的指针，它们指向的根内存的空间。

## GC算法的实现方式
现在大概两种：追踪式和引用计数式：
专业的定义：
> 追踪式GC：从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。
> 引用计数式GC：每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。

垃圾回收暂时就到这里：
wait updating...
# Go语言高级教程
# 语言基础
## 数组, 字符串, 切片
这三个数据结构在底层密切相关. 

### 数组
> Go语言中数组、字符串和切片三者是密切相关的数据结构。这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。

> 和C语言中的数组不同(隐性的指向第一个元素的指针), go的**整个数组就是一个值**. 数组的初始化有几个重要特征: 1. 大小一定固定 2. 可以通过索引赋值. 3. 元素如果默认为对应数据类型的零值. 

> Go语言的数组是一个完整的值. 这意味着它的参数是 **值传递**. (实际上 Go语言除了闭包的外部引用全部都是值传递). 不管数组多大, 都会复制一个完整的副本下来, 开销较大. 一般推荐使用一个指向数组的指针. 
例如: 
```go
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针

fmt.Println(a[0], a[1])   // 打印数组的前2个元素
fmt.Println(b[0], b[1])   // 通过数组指针访问数组元素的方式和数组类似

for i, v := range b {     // 通过数组指针迭代数组的元素
    fmt.Println(i, v)
}
```

不过即使这样数组的使用也依旧不够灵活, 因为**数组的长度是数组的一部分**, 因此**算作不同的类型**. 
> 要我类比的话, 数组就是一个结构体, 索引就是内部不同的结构体的字段, 那么长度不同的数组相当于字段数都不同, 那么他们当然就不能算同一种数据类型了.

数组不仅仅可以用于数值类型，还可以定义字符串数组、结构体数组、函数数组、接口数组、管道数组 and so on.
此外, 还存在空数组. 
空数组和空结构体一样, 可以用来做某种单纯的 "占位符", 因为他们不占据额外的内存空间. 例如用于管道的同步操作: 
```go
 c2 := make(chan struct{})
    go func() {
        fmt.Println("c2")
        c2 <- struct{}{} // struct{}部分是类型, {}表示对应的结构体值
    }()
    <-c2
```

我们可以用fmt.Printf函数提供的%T或%#v谓词语法来打印数组的类型和详细信息：
```go
 fmt.Printf("b: %T\n", b)  // b: [3]int
    fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```

总之, 数组是底层数据结构实现的基础, 调试和优化必须要熟悉数组.

### string
go的字符串有着许多和上上世纪语言相比不一样的特性. 
一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，

**和数组的不同之处**
- 字符串的元素不可修改，是一个只读的字节数组。而数组对应索引的的数值是可以修改的. 
- 数组的长度是其类型组成的一部分. 但是字符串不是. 

之前已经提到, 字符串的底层是一个 字节数组. 他的类型被go定义成了一个新的类型: rune. 会被go根据UTF-8字符来解析. 
大部分时候, 你最好把它**看作是一个只读的二进制数组更准确**，因为for range等语法并不能支持非UTF8编码的字符串的遍历。

string的底层是 StringHeader, 是一个结构体, 字段为一个指向字节数组的指针和长度. 因此, 字符串很像所谓的引用类型, 它的赋值实际上是指针的赋值. 
尽管 不是切片, 但是string支持一部分的切片操作.

说说uft-8的问题, 根据Go语言规范，Go语言的源文件都是采用UTF8编码。 因此, 如果使用 UTF-8的规范去处理它会出现乱码的情况. 
书里的说明就想数学的证明定义一样复杂, 我记住了最关键的一个: []rune和 string 在底层的相互转换是有额外开销的. 


# Go语言并发

## 零碎的笔记, 可能需要整理的
常见的并行编程有多种模型，主要有多线程、消息传递**两种**。
现代常用编程语言多使用 多线程编程, 消息传递的机制是 Erlang语言的代表特性.

Go语言从源码级别就支持 并发, 它将基于CSP模型的并发编程内置到了语言中. (Go语言高级编程的原话) Go语言的 goroutine是共享内存的.

根据书中所讲: 
> 首先，每个系统级线程都会有一个固定大小的栈（一般默认可能是2MB），这个栈主要用来保存函数递归调用时参数和局部变量。固定了栈的大小导致了两个问题：一是对于很多只需要很小的栈空间的线程来说是一个巨大的浪费，二是对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。针对这两个问题的解决方案是：要么降低固定的栈大小，提升空间的利用率；要么增大栈的大小以允许更深的函数递归调用，但这两者是没法同时兼得的。相反，一个Goroutine会以一个很小的栈启动（可能是2KB或4KB），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达到1GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个Goroutine。

线程的不足之处在于: 每一个的栈大小设置的不合理, 并且不能动态调整. (个人觉得这并不能称之为特性, 因为其他的语言有可能也可以突破这个限制, 或者有对应的多线程框架来实现.) 
而 go的在运行时有一个自己的调度器, 使用半抢占式的调度(阻塞时才调度). 总之, goroutine的代价相比其他语言的多线程编程极低. 

**原子操作**
定义: 
> 所谓的原子操作就是并发编程中“最小的且不可并行化”的操作。

因此, 那么同一时刻最多**只能有一个并发体对该资源进行操作**。
等价于, 对于原子资源, 它的操作永远是单线程. 

原子操作通过 设置**互斥**保证.
原生的上锁机制的效率很低, 并且容易出错.

Go语言的 sync包提供了一个 